<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Calispel</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="top"></a>Calispel</h1></div><div><div class="author"><h3 class="author"><span class="firstname">J.P.</span> <span class="surname">Larocque</span></h3></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec-intro">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#sec-obtaining">1.1. Obtaining Calispel</a></span></dt><dt><span class="section"><a href="#sec-copying">1.2. Copying</a></span></dt><dt><span class="section"><a href="#sec-contact">1.3. Contact Information</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-examples">2. Examples</a></span></dt><dt><span class="section"><a href="#sec-reference">3. Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#sec-channel">3.1. The <code class="type">CHANNEL</code> Class</a></span></dt><dt><span class="section"><a href="#sec-basic_io">3.2. <code class="function">?</code> and <code class="function">!</code>:
	Basic I/O Functions</a></span></dt><dt><span class="section"><a href="#sec-alt_macros">3.3. <code class="function">PRI-ALT</code>
	and <code class="function">FAIR-ALT</code>: Alternation Among Several
	Operations</a></span></dt><dt><span class="section"><a href="#sec-dynamic_alternation">3.4. Dynamic Alternation</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-intro"></a>1. Introduction</h2></div></div></div><p>Calispel is a Common Lisp library for thread-safe
      message-passing channels, in the style of the occam programming
      language.</p><p>Calispel channels let one thread communicate with another,
      facilitating unidirectional communication of any Lisp object.
      Channels may be unbuffered, where a sender waits for a receiver
      (or vice versa) before either operation can continue, or
      channels may be buffered with flexible policy options.</p><p>Because sending and receiving on a channel may block, either
      operation can time out after a specified amount of time.</p><p>A syntax for alternation is provided (like <code class="code">ALT</code>
      in occam, or Unix <code class="code">select()</code>): given a sequence of
      operations, any or all of which may block, alternation selects
      the first operation that doesn't block and executes associated
      code.  Alternation can also time out, executing an "otherwise"
      clause if no operation becomes available within a set amount of
      time.</p><p>Many CSP- and occam-style channel libraries offer features
      like parallel execution (i.e. occam <code class="code">PAR</code>).  Calispel
      is a message-passing library, and as such leaves the role of
      threading abstractions and utilities left to be filled by
      perfectly good, complementary libraries such
      as <a class="ulink" href="http://common-lisp.net/project/bordeaux-threads/" target="_top">Bordeaux-Threads</a>
      and <a class="ulink" href="http://common-lisp.net/project/eager-future/" target="_top">Eager
      Future</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-obtaining"></a>1.1. Obtaining Calispel</h3></div></div></div><p>The latest version of Calispel, with accompanying
      documentation, can be found at:
      <a class="ulink" href="http://www.thoughtcrime.us/software/calispel/" target="_top">http://www.thoughtcrime.us/software/calispel/</a></p><p>The most recent release is 0.1, released 2009-10-19.  It
	depends on:
	<span class="simplelist"><a class="ulink" href="http://www.thoughtcrime.us/software/jpl-queues/" target="_top">jpl-queues</a>
	    0.1, <a class="ulink" href="http://www.thoughtcrime.us/software/cl-jpl-util/" target="_top">cl-jpl-util</a>
	    0.2, <a class="ulink" href="http://common-lisp.net/project/eager-future/" target="_top">Eager Future</a>
	    0.1, <a class="ulink" href="http://common-lisp.net/project/bordeaux-threads/" target="_top">Bordeaux Threads</a></span>
	
	</p><div class="itemizedlist"><ul type="disc"><li><a class="ulink" href="http://www.thoughtcrime.us/software/calispel/calispel-0.1.tar.gz" target="_top">calispel-0.1.tar.gz</a>:
	    ASDF package</li><li><a class="ulink" href="http://www.thoughtcrime.us/software/calispel/calispel-0.1.tar.gz.sign" target="_top">calispel-0.1.tar.gz.sign</a>:
            OpenPGP detached signature</li></ul></div><p>
      </p><p>I sign all my software with OpenPGP, key ID 0x80555CED7394F948,
	fingerprint 2771 AF53 5D09 BDFB A8D0 BEF3 8055 5CED 7394 F948.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-copying"></a>1.2. Copying</h3></div></div></div><p>The software and this document are licensed under
	permissive, BSD-like terms, copied from the ISC
	license:</p><div class="blockquote"><blockquote class="blockquote"><p>Copyright © 2009, Jean-Paul Guy Larocque</p><p>Permission to use, copy, modify, and/or distribute this
	  software for any purpose with or without fee is hereby
	  granted, provided that the above copyright notice and this
	  permission notice appear in all copies.</p><p>THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR
	  DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
	  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
	  FITNESS.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
	  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
	  PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH
	  THE USE OR PERFORMANCE OF THIS SOFTWARE.</p></blockquote></div><p>This software was directly derived from
	"<a class="ulink" href="http://www.staff.ncl.ac.uk/roger.peppe/csp.tgz" target="_top">csp.tgz</a>",
	dated 2006-07-03, and published by Roger Peppe.  No copyright
	notice giving attribution to Roger Peppe or any specific
	licensing terms seem to have been included in that
	version.</p><p>That software was derived from "channel.c" of Plan 9
	libthread:</p><div class="blockquote"><blockquote class="blockquote"><p>Copyright © 2005 Russ Cox, Massachusetts Institute
	  of Technology</p><p>Permission is hereby granted, free of charge, to any
	  person obtaining a copy of this software and associated
	  documentation files (the "Software"), to deal in the
	  Software without restriction, including without limitation
	  the rights to use, copy, modify, merge, publish, distribute,
	  sublicense, and/or sell copies of the Software, and to
	  permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:</p><p>The above copyright notice and this permission notice
	  shall be included in all copies or substantial portions of
	  the Software.</p><p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
	  ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
	  THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
	  PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
	  OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
	  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.</p></blockquote></div><p>That software contains parts derived from an earlier
	library by Rob Pike, Sape Mullender, and Russ Cox:</p><div class="blockquote"><blockquote class="blockquote"><p>Copyright © 2003 by Lucent Technologies.</p><p>Permission to use, copy, modify, and distribute this
	  software for any purpose without fee is hereby granted,
	  provided that this entire notice is included in all copies
	  of any software which is or includes a copy or modification
	  of this software and in all copies of the supporting
	  documentation for such software.</p><p>THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
	  IMPLIED WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT
	  TECHNOLOGIES MAKE ANY REPRESENTATION OR WARRANTY OF ANY KIND
	  CONCERNING THE MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR
	  ANY PARTICULAR PURPOSE.</p></blockquote></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-contact"></a>1.3. Contact Information</h3></div></div></div><p>The author welcomes feedback, questions, help requests,
	and bug reports via e-mail: J.P. Larocque &lt;jpl-software at
	thoughtcrime.us&gt;</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-examples"></a>2. Examples</h2></div></div></div><p>Create a channel with no buffering:</p><div class="informalexample"><pre class="programlisting">(defparameter *chan*
  (make-instance 'calispel:channel))</pre></div><p>In another thread, sleep for 1 second, then send the number
      42 to the channel.  In the current thread, receive from the
      channel.  At first, there will be no value available,
      so <a class="link" href="#sec-basic_io" title="3.2. ? and !: Basic I/O Functions"><code class="function">?</code></a>
      will wait until the other thread sends the value.</p><div class="informalexample"><pre class="programlisting">(progn
  (eager-future:pexec
    (sleep 1)
    (calispel:! *chan* 42))
  (calispel:? *chan*))
=&gt; 42
   T</pre></div><p>(<code class="literal">42</code> is the value received,
      and <code class="literal">T</code> indicates that the receive was
      successful—it did not time out.)</p><p>Sending to the channel will also block without a waiting
      receiver, because channels are unbuffered by default.  This will
      attempt to send to the channel, then time out after 2
      seconds:</p><div class="informalexample"><pre class="programlisting">(calispel:! *chan* 'foo 2)
=&gt; NIL</pre></div><p>(<code class="literal">NIL</code> indicates that the send was not
      successful—it timed out.)</p><p>Create a new channel that is buffered:</p><div class="informalexample"><pre class="programlisting">(defparameter *chan*
  (make-instance 'calispel:channel
                 :buffer (make-instance '<a class="ulink" href="http://www.thoughtcrime.us/software/jpl-queues/#sec-classes-bounded_fifo_queue" target="_top">jpl-queues:bounded-fifo-queue</a> :capacity 2)))</pre></div><p>This channel will accept up to two values that have not yet
      been received before sends will block:</p><div class="informalexample"><pre class="programlisting">(loop for i from 1
      while (calispel:! *chan* i 0)
      finally (format t "~&amp;Stopped before ~:R value.~&amp;" i))
&gt;&gt; Stopped before third value.</pre></div><p>Now let's print them back out:</p><div class="informalexample"><pre class="programlisting">(loop
  (multiple-value-bind (value success?)
      (calispel:? *chan* 0)
    (when success?
      (format t "~&amp;Value: ~S~&amp;" value))
    (unless success?
      (return))))
&gt;&gt; Value: 1
Value: 2</pre></div><p>Suppose that we have many channels that we're interested in
      receiving from or sending to.  We can
      use <a class="link" href="#sec-alt_macros" title="3.3. PRI-ALT and FAIR-ALT: Alternation Among Several Operations">alternation</a> to select
      the first operation that is available, and then perform some
      action associated with the operation:</p><div class="informalexample"><pre class="programlisting">(let ((chan1 (make-instance 'calispel:channel)) ; chan1 goes unused
      (chan2 (make-instance 'calispel:channel)))
  (eager-future:pexec
    (calispel:! chan2 42))
  (calispel:pri-alt
    ((calispel:? chan1)
     ;; Nothing is sent to CHAN1, so it can't be ready.
     (format t "~&amp;Got a value from CHAN1, but that should never happen.~&amp;"))
    ((calispel:? chan2 value)
     ;; CHAN2 has either had something sent to it, or it soon will,
     ;; so this will execute.
     (format t "~&amp;Got value from CHAN2: ~S~&amp;" value))))
&gt;&gt; Got value from CHAN2: 42</pre></div><p>What if there's more than one operation that is immediately
      possible?  <a class="link" href="#sec-alt_macros" title="3.3. PRI-ALT and FAIR-ALT: Alternation Among Several Operations"><code class="function">PRI-ALT</code></a>
      chooses the first one available...</p><div class="informalexample"><pre class="programlisting">(let ((chan1 (make-instance 'calispel:channel))
      (chan2 (make-instance 'calispel:channel)))
  (eager-future:pexec
    (calispel:! chan1 'foo))
  (eager-future:pexec
    (calispel:! chan2 'bar))
  (sleep 1) ; Wait for both CHAN1 and CHAN2 to become ready.
  (calispel:pri-alt
    ((calispel:? chan1 value)
     (format t "~&amp;Got value from CHAN1: ~S~&amp;" value))
    ((calispel:? chan2 value)
     (format t "~&amp;Got value from CHAN2: ~S~&amp;" value))))
&gt;&gt; Got value from CHAN1: FOO</pre></div><p>...whereas <a class="link" href="#sec-alt_macros" title="3.3. PRI-ALT and FAIR-ALT: Alternation Among Several Operations"><code class="function">FAIR-ALT</code></a>
      chooses any of the available operations:</p><div class="informalexample"><pre class="programlisting">(let ((chan1 (make-instance 'calispel:channel))
      (chan2 (make-instance 'calispel:channel)))
  (eager-future:pexec
    (calispel:! chan1 'foo))
  (eager-future:pexec
    (calispel:! chan2 'bar))
  (sleep 1) ; Wait for both CHAN1 and CHAN2 to become ready.
  (calispel:fair-alt
    ((calispel:? chan1 value)
     (format t "~&amp;Got value from CHAN1: ~S~&amp;" value))
    ((calispel:? chan2 value)
     (format t "~&amp;Got value from CHAN2: ~S~&amp;" value))))
&gt;&gt; Got value from CHAN1: FOO
<span class="emphasis"><em>(or, determined randomly)</em></span>
&gt;&gt; Got value from CHAN2: BAR</pre></div><p>Just
      like <a class="link" href="#sec-basic_io" title="3.2. ? and !: Basic I/O Functions"><code class="function">?</code>
      and <code class="function">!</code></a>, <code class="function">PRI-ALT</code>
      and <code class="function">FAIR-ALT</code> allow time outs to be
      specified.  An <code class="code">OTHERWISE</code> clause is executed if no
      operation can be immediately performed, effectively putting a
      time out of 0 on all the operations:</p><div class="informalexample"><pre class="programlisting">(let ((chan1 (make-instance 'calispel:channel))
      (chan2 (make-instance 'calispel:channel)))
  (eager-future:pexec
    (sleep 1)
    (calispel:! chan1 'foo))
  (calispel:pri-alt
    ((calispel:? chan1 value)
     (format t "~&amp;Got value from CHAN1: ~S~&amp;" value))
    ((calispel:? chan2 value)
     (format t "~&amp;Got value from CHAN2: ~S~&amp;" value))
    (otherwise (format t "~&amp;Timed-out.~&amp;"))))
&gt;&gt; Timed-out.</pre></div><p>You can also wait up to a certain amount of time before
      executing the <code class="code">OTHERWISE</code> clause:</p><div class="informalexample"><pre class="programlisting">(let ((chan1 (make-instance 'calispel:channel))
      (chan2 (make-instance 'calispel:channel)))
  (eager-future:pexec
    (sleep 1)
    (calispel:! chan1 'foo))
  (calispel:pri-alt
    ((calispel:? chan1 value)
     (format t "~&amp;Got value from CHAN1: ~S~&amp;" value))
    ((calispel:? chan2 value)
     (format t "~&amp;Got value from CHAN2: ~S~&amp;" value))
    ((otherwise :timeout 5)
     (format t "~&amp;Timed-out.~&amp;"))))
&gt;&gt; Got value from CHAN1: FOO</pre></div><p>(Try increasing the <code class="function">SLEEP</code> delay to 6
      to see that the <code class="function">PRI-ALT</code> will still time
      out.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-reference"></a>3. Reference</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-channel"></a>3.1. The <code class="type">CHANNEL</code> Class</h3></div></div></div><p><b>Syntax. </b></p><pre class="synopsis">(<code class="function">MAKE-INSTANCE</code> <code class="literal">'CHANNEL</code> &amp;key <code class="varname">BUFFER</code>)
=&gt; <span class="emphasis"><em>(A <code class="type">CHANNEL</code> instance.)</em></span></pre><p>A channel is a medium that communicates messages from one
	thread to another.</p><p>All channels have a buffer.  The default buffer doesn't do
	anything—it's always full and always empty.  It has no
	storage.</p><p><code class="code">BUFFER</code> specifies
	the <a class="ulink" href="http://www.thoughtcrime.us/software/jpl-queues/#sec-classes" target="_top">jpl-queues
	  queue</a> to buffer messages with.</p><p>Sending to a channel blocks when there is no other thread
	waiting to receive from it and there is no room in the buffer
	(i.e. <a class="ulink" href="http://www.thoughtcrime.us/software/jpl-queues/#sec-api-full" target="_top"><code class="function">JPL-QUEUES:FULL?</code></a>
	returns true).  Receiving from a channel blocks when there is
	no other thread waiting to send to it and there are no objects
	in the buffer
	(i.e. <a class="ulink" href="http://www.thoughtcrime.us/software/jpl-queues/#sec-api-empty" target="_top"><code class="function">JPL-QUEUES:EMPTY?</code></a>
	returns true).</p><p>To improve throughput with better parallelism, a
	meaningful buffer is recommended so that threads can perform
	useful work instead of waiting on other threads.
	Any jpl-queues queue may be used, but
	note:</p><div class="itemizedlist"><ul type="disc"><li>The queue need not be "synchronized" (an instance
	  of <code class="type">JPL-QUEUES:SYNCHRONIZED-QUEUE</code>): Calispel has
	  its own synchronization, so external synchronization will only
	  add overhead.</li><li>The queue may not be shared with any other channels
	  or be used for anything else, even if it's "synchronized."
	  (Pedantic exception: if the queue strictly has no state,
	  then it doesn't matter if it's shared.  The default "null"
	  queue has no state, and it is shared.)</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-basic_io"></a>3.2. <code class="function">?</code> and <code class="function">!</code>:
	Basic I/O Functions</h3></div></div></div><p><b>Syntax. </b></p><pre class="synopsis">(<code class="function">?</code> <code class="varname">CHANNEL</code> &amp;optional <code class="varname">TIMEOUT</code>)
=&gt; <code class="varname">VALUE</code>
   <code class="varname">RECEIVED-OK?</code></pre><pre class="synopsis">(<code class="function">!</code> <code class="varname">CHANNEL</code> <code class="varname">VALUE</code> &amp;optional <code class="varname">TIMEOUT</code>)
=&gt; <code class="varname">SENT-OK?</code></pre><p><code class="function">?</code> receives a value
	from <code class="varname">CHANNEL</code>, waiting up
	to <code class="varname">TIMEOUT</code> seconds (a
	non-negative <a class="ulink" href="http://www.lispworks.com/documentation/HyperSpec/Body/t_real.htm#real" target="_top"><code class="type">REAL</code></a>
	number; or indefinitely if unspecified
	or <code class="literal">NIL</code>).  If a value can be received before
	the time out, the value and <code class="literal">T</code> (indicating
	success) are returned.  Otherwise, <code class="literal">NIL</code>
	and <code class="literal">NIL</code> (indicating failure) are
	returned.</p><p><code class="function">!</code> sends <code class="varname">VALUE</code>
	to <code class="varname">CHANNEL</code>, waiting up
	to <code class="varname">TIMEOUT</code> seconds (a
	non-negative <a class="ulink" href="http://www.lispworks.com/documentation/HyperSpec/Body/t_real.htm#real" target="_top"><code class="type">REAL</code></a>
	number; or indefinitely if unspecified
	or <code class="literal">NIL</code>).  If the value can be sent before
	the time out, <code class="literal">T</code> (indicating success) is
	returned.  Otherwise, <code class="literal">NIL</code> (indicating
	failure) is returned.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-alt_macros"></a>3.3. <code class="function">PRI-ALT</code>
	and <code class="function">FAIR-ALT</code>: Alternation Among Several
	Operations</h3></div></div></div><p><b>Syntax. </b></p><pre class="synopsis">(<code class="function">PRI-ALT</code> operation-clause* [otherwise-clause])
(<code class="function">FAIR-ALT</code> operation-clause* [otherwise-clause])
=&gt; <span class="emphasis"><em>(For either macro: the result of the final evaluated <code class="varname">form</code>,
    or no values if no clause was executed.)</em></span>

operation-clause ::= (operation <code class="varname">form</code>*)
otherwise-clause ::= ({otherwise | (otherwise [:timeout <code class="varname">timeout</code>])} <code class="varname">form</code>*)
operation        ::= (? <code class="varname">channel</code> [<code class="varname">lambda-list</code> [<code class="varname">condition</code>]]) ; receive
                   | (! <code class="varname">channel</code> <code class="varname">value</code> [<code class="varname">condition</code>])         ; send</pre><p>Performs one of the given channel operations, choosing one
	from the set of operations that first becomes available, then
	evaluates each of the forms associated with the selected
	operation.  If no operation can immediately be made, waits
	until an operation is available (optionally up to a given
	<code class="code">timeout</code>).</p><p>When there are multiple operations that can be immediately
	carried-out, <code class="function">PRI-ALT</code> selects the first
	one listed, whereas <code class="function">FAIR-ALT</code> chooses one
	at random.</p><div class="variablelist"><dl><dt><span class="term"><code class="varname">channel</code></span></dt><dd><p>Evaluated to produce
	      a <a class="link" href="#sec-channel" title="3.1. The CHANNEL Class"><code class="type">CHANNEL</code></a>
	      to send to or receive from.  The channel forms
	      associated with operations that do not pass the
	      condition are not evaluated.</p></dd><dt><span class="term"><code class="varname">lambda-list</code></span></dt><dd><p>Either a symbol naming a variable to be bound to the
	      value received from the channel, or a destructuring lambda
	      list<sup>[<a name="destructuring_lambda_list" href="#ftn.destructuring_lambda_list" class="footnote">1</a>]</sup> naming a set of variables to be bound to the
	      destructured value received from the channel.  The
	      bindings are visible to the associated forms.  If the
	      value cannot be destructured according to the lambda
	      list, an error is signalled.  Note that multiple receive
	      clauses for the same channel with different
	      destructuring lambda-lists <span class="emphasis"><em>cannot</em></span>
	      be used for pattern matching.</p></dd><dt><span class="term"><code class="varname">value</code></span></dt><dd><p>An expression whose primary value is used as the
	      message to send to the channel.  All value expressions
	      are evaluated before selecting an operation, except for
	      those associated with operations that do not pass the
	      condition.</p></dd><dt><span class="term"><code class="varname">condition</code></span></dt><dd><p>Evaluated to produce a generalized boolean
	      indicating whether the associated operation-clause
	      should receive further consideration.  When condition is
	      not given or its resulting value is true, the associated
	      operation is kept for consideration.  When the resulting
	      value is false, the operation is removed from
	      consideration (as if its associated channel never
	      becomes ready for sending/receiving).</p></dd><dt><span class="term"><code class="varname">form</code></span></dt><dd><p>Evaluated in sequence when the associated clause is
	      executed.  The values of the evaluation of the last form
	      of the effective clause become the result of the
	      macro.</p></dd><dt><span class="term"><code class="varname">timeout</code></span></dt><dd><p>Evaluated to produce the duration, as a non-negative
	      <a class="ulink" href="http://www.lispworks.com/documentation/HyperSpec/Body/t_real.htm#real" target="_top"><code class="type">REAL</code></a>
	      number of seconds, to wait for an effective operation to
	      become available before resorting to the
	      <code class="code">otherwise-clause</code>.  The result may also
	      be <code class="literal">NIL</code> to specify no time out.  When
	      an <code class="code">otherwise-clause</code> exists, the default
	      time out is 0, meaning that if none of the channels in
	      the operation-clauses are immediately available, the
	      <code class="code">otherwise-clause</code> forms are executed
	      immediately.  When there is
	      no <code class="code">otherwise-clause</code>, the default time out
	      is
	      <code class="literal">NIL</code>.</p></dd></dl></div><p>It is useful to specify a <code class="code">timeout</code> expression that
	conditionally evaluates to <code class="literal">NIL</code>, in order to
	disable the time out and inhibit the execution of the
	<code class="code">otherwise-clause</code> (provided that there are channel
	operations to wait for that haven't been excluded by false
	conditions).</p><p>If there are no effective operations (because all the
	conditions evaluated to false, or because no operations were
	specified), then the <code class="code">otherwise-clause</code> (if any) is
	executed immediately (even if the specified time out
	is <code class="literal">NIL</code>).</p><p>Stylistically and for future compatibility, avoid
	side-effects
	in <code class="code">channel</code>, <code class="code">value</code>, <code class="code">condition</code>,
	and <code class="code">timeout</code> expressions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sec-dynamic_alternation"></a>3.4. Dynamic Alternation</h3></div></div></div><p>It is possible to dynamically construct a set of
	operations to alternate upon.</p><p>The general procedure is to
	instantiate <code class="type">OPERATION</code> for each kind of operation
	you wish to perform.  For sending operations, you will need to
	give the value to send with <code class="code">:VALUE</code>.  Pass
	the <code class="type">OPERATION</code> instances, as a list,
	to <code class="function">OPERATION-ALTERNATE</code>.  <code class="function">OPERATION-ALTERNATE</code>
	will either immediately execute one of
	the <code class="type">OPERATION</code> instances, or block until another
	thread executes an operation which allows one of the given
	operations to execute.  The selected operation, after having
	been executed, is returned.  If the selected operation was a
	receive operation, the value received will available with
	the <code class="function">VALUE</code> accessor.</p><p>Please see the documentation in the source code
	for <code class="function">OPERATION-ALTERNATE</code> and
	the <code class="type">OPERATION</code> class.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.destructuring_lambda_list" href="#destructuring_lambda_list" class="para">1</a>] </sup>See: Common Lisp HyperSpec,
		sec. <a class="ulink" href="http://www.lispworks.com/documentation/HyperSpec/Body/03_de.htm" target="_top">3.4.5
		Destructuring Lambda Lists</a></p></div></div></div></body></html>
